ADMIN




To explain this technical architecture to a marketing expert, we need to shift the focus from "how the code works" to "how this drives business value, user experience, and brand trust."
Here is how a Marketing Expert would translate your technical functions into strategic advantages:
1. Brand Consistency & Security (Utility Functions)
 * The "Polished Look" ($ / show / hide / setActiveMenu): These ensure the user interface is smooth and intuitive. By highlighting the active menu and showing only relevant screens, we reduce "cognitive load," making the admin feel in control and the platform feel professional.
 * The "Component Factory" (elCreate): This allows us to build new features quickly using standardized designs, ensuring the LearnBridge brand looks identical across every page.
 * The "Shield" (escapeHtml): This is a PR safeguard. It prevents hackers from injecting malicious text into our site, protecting our reputation and keeping user data safe from "vandalism."
2. Seamless User Journey (Navigation & Core)
 * The "Concierge" (showSection / initAdminPortal): These act as the navigation guide. They ensure that when an admin clicks a button, the system "pre-fetches" exactly what they need so there is no lag, creating a premium software experience.
 * The "Gatekeeper" (onAuthStateChanged): This protects our "Premium/Internal" content. It ensures only authorized personnel can see university data, which is a massive selling point for institutional trust.
3. Identity Management (Admin Profile)
 * Credential Management (load/saveAdminProfile): This allows for personalized accountability. We can see exactly which staff member is managing the portal, which helps in maintaining high internal service standards.
4. Data-Driven Insights (Dashboard & Analytics)
 * Real-Time "Pulse" Check (loadDashboardMetrics): This provides an instant "Health Score" of the university. We can see if sign-ups are up or if thereâ€™s a backlog of students waiting for help.
 * Customer Satisfaction Tracking (loadOverallAnalytics): This is our "Net Promoter Score" (NPS) engine. It tells us which tutors are our "Star Performers" and where we need to improve our service quality to keep students happy.
5. Community Growth & Quality Control (User Management)
 * The "Talent Filter" (loadAllUsers / handleApproveUser): This is our quality assurance process. We don't let just anyone onto the platform; we vet tutors and counsellors to ensure the "LearnBridge" brand represents excellence.
 * "Brand Protection" (handleViewEditUser / Bulk Actions): If a user violates our community guidelines, these tools allow us to "pause" their access instantly to protect the rest of the student body.
6. Service Delivery (Sessions & Bookings)
 * Operations Management (loadAllSessions / loadAllPendingRequests): This is the "Engine Room." It ensures that the "product" (the tutoring session) is actually being delivered.
 * The "Executive Override" (handleAdminApprove/Reject): This allows us to provide "White Glove" service. If a high-priority student has a booking issue, an admin can step in manually to fix it, ensuring 100% satisfaction.
7. Crisis Management & PR (Support & Communication)
 * The "Customer Success Desk" (loadAllIssues / handleViewIssue): This ensures no student or tutor feels ignored. By color-coding "Urgent" issues, we can prioritize the biggest "fires" first to prevent negative social media talk.
 * The "Broadcaster" (sendSystemAnnouncement): This is our direct marketing channel. We can send system-wide updates, deadline reminders, or emergency alerts directly to our users' pockets, ensuring high engagement.
8. Transparency & Compliance (Audit & Reporting)
 * The "Paper Trail" (loadAuditLogs): For a university, compliance is everything. This keeps a record of every major change for legal and safety audits.
 * "Executive Summaries" (handleGenerateReport): These are the reports we show to the University Board. They turn thousands of data points into a simple PDF that proves the ROI (Return on Investment) of the LearnBridge platform.
Would you like me to help you draft a "Marketing Summary" or a "Sales Pitch" based on these features for a university presentation?







TUTOR







For a marketing expert, the focus shifts from how the code works to what value it provides to the user (the tutor) and how it enhances the "customer experience" for the student.
If you were explaining this to a stakeholder or a client, here is how you would pitch each feature point-by-point:
1. Core User Interface & Experience (UI/UX)
 * $ (Shorthand Helper): This is our "efficiency engine" that ensures the app stays lightweight and snappy for the user.
 * show / hide: These control the "stage directions," ensuring the tutor only sees relevant information at the right time, preventing information overload.
 * setActiveMenu: This acts as a "GPS," visually highlighting exactly where the tutor is within the portal so they never feel lost.
 * elCreate: Our "on-demand builder" that generates interface elements instantly based on the data being received.
 * escapeHtml: A "security shield" that protects the brand by sanitizing user input, ensuring no malicious text breaks the website's layout or safety.
 * onAuthStateChanged: The "Digital Concierge." It greets the tutor when they arrive, verifies their identity, and politely redirects unauthorized visitors away from sensitive data.
 * initPortal: The "Grand Opening" sequence. It connects all the buttons to their actions and prepares the desk for the tutor's workday.
 * showSection: The "Virtual Room Switcher," allowing the tutor to flip between their calendar, chat, and profile without ever having to reload the page.
2. Profile & Brand Management
 * loadProfile: The "Identity Verified" check. It ensures only certified tutors can access professional tools and pulls in their unique bio and credentials.
 * saveProfile: The "Professional Portfolio Updater." It allows tutors to keep their "storefront" fresh with new modules and rates, while ensuring their official status remains intact.
 * loadDashboard: The "Executive Summary." It gives the tutor a 30,000-foot view of their performance, schedule, and earnings for the week.
 * loadPendingCounts: The "Urgency Indicator." It places a red alert on the menu to ensure no student request is ignored or left behind.
3. Session & Lead Management
 * loadUpcomingTutorials: The "Daily Itinerary," providing a clear, organized view of all confirmed bookings.
 * handleStartTutorial: The "Virtual Classroom Launcher." It transitions a scheduled appointment into an active service delivery session with one click.
 * loadStudentRequests: The "Sales Pipeline." This is where the tutor reviews new business leads and decides which students to accept or negotiate with.
 * checkConflictForPerson: The "Double-Booking Guard." It acts as an automated assistant that prevents embarrassing scheduling overlaps.
 * findNextAvailable: The "Smart Rescheduler." If a conflict exists, it proactively finds an alternative time, reducing friction and keeping the sale alive.
4. Availability & Status Control
 * openAvailabilityEditor: The "Schedule Architect," giving tutors full control over their work-life balance.
 * renderAvailabilityTable: The "Live Visualizer," showing the tutor exactly what their public-facing schedule looks like.
 * Presets (All Week/Evenings): "One-Touch Templates" that allow tutors to set up their entire weekly availability in seconds rather than minutes.
 * toggleAvailableNowBtn: The "Open for Business" sign. It allows tutors to signal they are ready for instant, on-demand sessions.
 * offlineModeBtn: The "Do Not Disturb" switch, instantly pausing all new requests when the tutor needs a break.
5. Communication & Relationship Management
 * chatIdFor: The "Private Channel Creator," ensuring every conversation between a tutor and student is secure and organized.
 * openChatSelector: The "Contact Directory," making it easy to find and reach out to past or current students to build relationships.
 * openChatWindow: The "Engagement Hub," providing a modern, real-time messaging experience to keep students supported.
 * renderMessages: The "Conversation Flow," styling messages so they look like a professional, familiar chat app.
 * cleanupAllChatListeners: The "Privacy Sweep," ensuring that when a session ends, the connection is closed cleanly to save device battery and data.
 * loadNotifications: The "Activity Feed," keeping the tutor updated on every important event, from new bookings to cancellations.
 * loadTutorFeedback: The "Reputation Manager." It displays student reviews, allowing tutors to see their "star rating" and improve their service quality.
 * sendIssueAsTutor: The "Support Ticket System," giving tutors a direct line to management if they encounter technical or student issues.
 * requestPasswordResetModal: The "Self-Service Security," allowing tutors to recover their accounts independently without needing to call support.
Would you like me to help you draft a "Value Proposition" for this portal to show potential tutors why they should use it?








rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

  /* ---------------- GLOBAL HELPER FUNCTIONS ---------------- */
function isAdmin() {
  return request.auth != null && 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
}

    
    // Check if the given UID belongs to a valid staff member (Tutor or Counsellor)
    function isStaff(staffId) {
        return get(/databases/$(database)/documents/users/$(staffId)).data.role in ['tutor', 'counsellor'];
    }

    /* ---------------- USERS ---------------- */
    match /users/{userId} {
      allow read: if request.auth != null; 
      
      // 1. CREATE: Allow new users to save their profile if they aren't trying to be Admin
      allow create: if request.auth != null 
                  && request.auth.uid == userId 
                  && request.resource.data.role != 'admin';

      // 2. UPDATE: Allow users to change their info, but block them from changing their role
      allow update: if request.auth != null && (
          (request.auth.uid == userId && request.resource.data.role == resource.data.role)
          || isAdmin()
      );

      allow delete: if isAdmin();
    }


    /* ---------------- SESSIONS ---------------- */
    match /sessions/{sessionId} {
      function isSessionParticipant() {
        return request.auth.uid == resource.data.studentId || 
               request.auth.uid == resource.data.personId; 
      }

      // 1. READ: Only participants and Admin can read specific sessions.
      allow read: if request.auth != null && (isSessionParticipant() || isAdmin()); 

      // 2. CREATE: Must be authenticated, set own studentId, AND the personId must be valid staff.
      allow create: if request.auth != null
                  && request.resource.data.studentId == request.auth.uid
                  && isStaff(request.resource.data.personId); 

      // 3. UPDATE/DELETE: Only participants and Admin (needs further refinement in a real app, 
      //    but acceptable for this level of portal simulation).
      allow update, delete: if request.auth != null && (isSessionParticipant() || isAdmin());
    }

    /* ---------------- RATINGS ---------------- */
    match /ratings/{ratingId} {
      // CREATE: Must be authenticated and set their own studentId
      allow create: if request.auth != null
                 && request.resource.data.studentId == request.auth.uid; 
      
      // READ: Admin, Student (their own), or Staff (ratings directed at them)
      allow read: if request.auth != null
                && (isAdmin()
                 || resource.data.studentId == request.auth.uid
                 || resource.data.personId == request.auth.uid); 
                 
      // UPDATE/DELETE: Admin only
      allow update, delete: if request.auth != null && isAdmin();
    }

    /* ---------------- CHATS (STANDARDIZED NESTED STRUCTURE) ---------------- */

    function isNestedChatParticipant(chatID) {
      // 1. Ensure the user is authenticated.
      // 2. Ensures the current user's UID is one of the two IDs that form the chatID (a__b).
      let uids = chatID.split('__');
      return request.auth != null
             && uids.size() == 2
             && (uids[0] == request.auth.uid || uids[1] == request.auth.uid);
    }
    
    // 1. CHAT DOCUMENT: /chats/{chatID}
    match /chats/{chatID} {
        // READ/UPDATE: Participants or Admin
        allow read, update: if isNestedChatParticipant(chatID) || isAdmin();
        
        // CREATE: Participants (when first message is sent)
        allow create: if isNestedChatParticipant(chatID);
        
        // DELETE: Only Admin
        allow delete: if isAdmin(); 
    }

    // 2. NESTED chat messages: /chats/{chatID}/messages/{messageId}
    match /chats/{chatID}/messages/{messageId} {

      // READ: Participants or Admin
      allow read: if isNestedChatParticipant(chatID) || isAdmin();

      // CREATE: Participant, AND senderId must match their authenticated UID
      allow create: if isNestedChatParticipant(chatID)
                 && request.auth.uid == request.resource.data.senderId
                 && request.resource.data.keys().hasAll(['senderId', 'text', 'timestamp']);
                 
      // UPDATE/DELETE: Disallow entirely (Messages should be immutable)
      allow update, delete: if false;
    }
    
    /* ---------------- SUPPORT TICKETS ---------------- */
    match /supportTickets/{ticketId} {
      // CREATE: Any authenticated user (student/staff)
      allow create: if request.auth != null;
      
      // READ/UPDATE/DELETE: Admin only (for internal management)
      allow read, update, delete: if isAdmin();
      
      // Student Read (can read their own submitted tickets)
      allow read: if request.auth.uid == resource.data.studentId;
    }
    
    /* ---------------- ADMIN OVERRIDE (Redundant but harmless due to other rules) ---------------- */
    match /{document=**} {
      allow read, write: if isAdmin();
    }
  }
}
