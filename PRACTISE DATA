TUTOR







For a marketing expert, the focus shifts from how the code works to what value it provides to the user (the tutor) and how it enhances the "customer experience" for the student.
If you were explaining this to a stakeholder or a client, here is how you would pitch each feature point-by-point:
1. Core User Interface & Experience (UI/UX)
 * $ (Shorthand Helper): This is our "efficiency engine" that ensures the app stays lightweight and snappy for the user.
 * show / hide: These control the "stage directions," ensuring the tutor only sees relevant information at the right time, preventing information overload.
 * setActiveMenu: This acts as a "GPS," visually highlighting exactly where the tutor is within the portal so they never feel lost.
 * elCreate: Our "on-demand builder" that generates interface elements instantly based on the data being received.
 * escapeHtml: A "security shield" that protects the brand by sanitizing user input, ensuring no malicious text breaks the website's layout or safety.
 * onAuthStateChanged: The "Digital Concierge." It greets the tutor when they arrive, verifies their identity, and politely redirects unauthorized visitors away from sensitive data.
 * initPortal: The "Grand Opening" sequence. It connects all the buttons to their actions and prepares the desk for the tutor's workday.
 * showSection: The "Virtual Room Switcher," allowing the tutor to flip between their calendar, chat, and profile without ever having to reload the page.
2. Profile & Brand Management
 * loadProfile: The "Identity Verified" check. It ensures only certified tutors can access professional tools and pulls in their unique bio and credentials.
 * saveProfile: The "Professional Portfolio Updater." It allows tutors to keep their "storefront" fresh with new modules and rates, while ensuring their official status remains intact.
 * loadDashboard: The "Executive Summary." It gives the tutor a 30,000-foot view of their performance, schedule, and earnings for the week.
 * loadPendingCounts: The "Urgency Indicator." It places a red alert on the menu to ensure no student request is ignored or left behind.
3. Session & Lead Management
 * loadUpcomingTutorials: The "Daily Itinerary," providing a clear, organized view of all confirmed bookings.
 * handleStartTutorial: The "Virtual Classroom Launcher." It transitions a scheduled appointment into an active service delivery session with one click.
 * loadStudentRequests: The "Sales Pipeline." This is where the tutor reviews new business leads and decides which students to accept or negotiate with.
 * checkConflictForPerson: The "Double-Booking Guard." It acts as an automated assistant that prevents embarrassing scheduling overlaps.
 * findNextAvailable: The "Smart Rescheduler." If a conflict exists, it proactively finds an alternative time, reducing friction and keeping the sale alive.
4. Availability & Status Control
 * openAvailabilityEditor: The "Schedule Architect," giving tutors full control over their work-life balance.
 * renderAvailabilityTable: The "Live Visualizer," showing the tutor exactly what their public-facing schedule looks like.
 * Presets (All Week/Evenings): "One-Touch Templates" that allow tutors to set up their entire weekly availability in seconds rather than minutes.
 * toggleAvailableNowBtn: The "Open for Business" sign. It allows tutors to signal they are ready for instant, on-demand sessions.
 * offlineModeBtn: The "Do Not Disturb" switch, instantly pausing all new requests when the tutor needs a break.
5. Communication & Relationship Management
 * chatIdFor: The "Private Channel Creator," ensuring every conversation between a tutor and student is secure and organized.
 * openChatSelector: The "Contact Directory," making it easy to find and reach out to past or current students to build relationships.
 * openChatWindow: The "Engagement Hub," providing a modern, real-time messaging experience to keep students supported.
 * renderMessages: The "Conversation Flow," styling messages so they look like a professional, familiar chat app.
 * cleanupAllChatListeners: The "Privacy Sweep," ensuring that when a session ends, the connection is closed cleanly to save device battery and data.
 * loadNotifications: The "Activity Feed," keeping the tutor updated on every important event, from new bookings to cancellations.
 * loadTutorFeedback: The "Reputation Manager." It displays student reviews, allowing tutors to see their "star rating" and improve their service quality.
 * sendIssueAsTutor: The "Support Ticket System," giving tutors a direct line to management if they encounter technical or student issues.
 * requestPasswordResetModal: The "Self-Service Security," allowing tutors to recover their accounts independently without needing to call support.
Would you like me to help you draft a "Value Proposition" for this portal to show potential tutors why they should use it?








rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

  /* ---------------- GLOBAL HELPER FUNCTIONS ---------------- */
function isAdmin() {
  return request.auth != null && 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
}

    
    // Check if the given UID belongs to a valid staff member (Tutor or Counsellor)
    function isStaff(staffId) {
        return get(/databases/$(database)/documents/users/$(staffId)).data.role in ['tutor', 'counsellor'];
    }

    /* ---------------- USERS ---------------- */
    match /users/{userId} {
      allow read: if request.auth != null; 
      
      // 1. CREATE: Allow new users to save their profile if they aren't trying to be Admin
      allow create: if request.auth != null 
                  && request.auth.uid == userId 
                  && request.resource.data.role != 'admin';

      // 2. UPDATE: Allow users to change their info, but block them from changing their role
      allow update: if request.auth != null && (
          (request.auth.uid == userId && request.resource.data.role == resource.data.role)
          || isAdmin()
      );

      allow delete: if isAdmin();
    }


    /* ---------------- SESSIONS ---------------- */
    match /sessions/{sessionId} {
      function isSessionParticipant() {
        return request.auth.uid == resource.data.studentId || 
               request.auth.uid == resource.data.personId; 
      }

      // 1. READ: Only participants and Admin can read specific sessions.
      allow read: if request.auth != null && (isSessionParticipant() || isAdmin()); 

      // 2. CREATE: Must be authenticated, set own studentId, AND the personId must be valid staff.
      allow create: if request.auth != null
                  && request.resource.data.studentId == request.auth.uid
                  && isStaff(request.resource.data.personId); 

      // 3. UPDATE/DELETE: Only participants and Admin (needs further refinement in a real app, 
      //    but acceptable for this level of portal simulation).
      allow update, delete: if request.auth != null && (isSessionParticipant() || isAdmin());
    }

    /* ---------------- RATINGS ---------------- */
    match /ratings/{ratingId} {
      // CREATE: Must be authenticated and set their own studentId
      allow create: if request.auth != null
                 && request.resource.data.studentId == request.auth.uid; 
      
      // READ: Admin, Student (their own), or Staff (ratings directed at them)
      allow read: if request.auth != null
                && (isAdmin()
                 || resource.data.studentId == request.auth.uid
                 || resource.data.personId == request.auth.uid); 
                 
      // UPDATE/DELETE: Admin only
      allow update, delete: if request.auth != null && isAdmin();
    }

    /* ---------------- CHATS (STANDARDIZED NESTED STRUCTURE) ---------------- */

    function isNestedChatParticipant(chatID) {
      // 1. Ensure the user is authenticated.
      // 2. Ensures the current user's UID is one of the two IDs that form the chatID (a__b).
      let uids = chatID.split('__');
      return request.auth != null
             && uids.size() == 2
             && (uids[0] == request.auth.uid || uids[1] == request.auth.uid);
    }
    
    // 1. CHAT DOCUMENT: /chats/{chatID}
    match /chats/{chatID} {
        // READ/UPDATE: Participants or Admin
        allow read, update: if isNestedChatParticipant(chatID) || isAdmin();
        
        // CREATE: Participants (when first message is sent)
        allow create: if isNestedChatParticipant(chatID);
        
        // DELETE: Only Admin
        allow delete: if isAdmin(); 
    }

    // 2. NESTED chat messages: /chats/{chatID}/messages/{messageId}
    match /chats/{chatID}/messages/{messageId} {

      // READ: Participants or Admin
      allow read: if isNestedChatParticipant(chatID) || isAdmin();

      // CREATE: Participant, AND senderId must match their authenticated UID
      allow create: if isNestedChatParticipant(chatID)
                 && request.auth.uid == request.resource.data.senderId
                 && request.resource.data.keys().hasAll(['senderId', 'text', 'timestamp']);
                 
      // UPDATE/DELETE: Disallow entirely (Messages should be immutable)
      allow update, delete: if false;
    }
    
    /* ---------------- SUPPORT TICKETS ---------------- */
    match /supportTickets/{ticketId} {
      // CREATE: Any authenticated user (student/staff)
      allow create: if request.auth != null;
      
      // READ/UPDATE/DELETE: Admin only (for internal management)
      allow read, update, delete: if isAdmin();
      
      // Student Read (can read their own submitted tickets)
      allow read: if request.auth.uid == resource.data.studentId;
    }
    
    /* ---------------- ADMIN OVERRIDE (Redundant but harmless due to other rules) ---------------- */
    match /{document=**} {
      allow read, write: if isAdmin();
    }
  }
}
